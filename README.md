# Euler1

** Multiples of 3 and 5

If we list all the natural numbers below 10 that are multiples of 3 or 5, we
get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

## Approach

In the order I came up with the answers:

### Euler1.using_stream/1

This solution is a pipeline of transforms ending with a sum. To be honest I
wasn't sure if Stream's laziness benefits Enum.sum/1 or not... doesn't seem to
however this method was definitely more performant at larger values. It's worth
noting that the private methods were not refactored out when I started the 2nd
approach - rather I started out writing using stream as it is and figured out
the implementation of the  private methods after the fact. I could have avoided
the private methods and left the transformation in line - but like the more
declarative pipeline in the function serving as the interface. It's more lines
of code but easier to follow.

If we ignore using_calculate_multiples/1 this method is fastest above 100,000
items - except that at 500,000 items using_map_reduce/1 ended up winning.

### Euler1.using_tail_call_optimization/1

Once I finished using_stream/1 I was curious how the method would look using
recursion. In this case I used a micropattern - having one arity of a method
serve as the interface and another arity of the same method serve as the
implementation.

I originally had a "local assignment" here:
`value_to_add = if desired_value?(head), do: head, else: 0` but considered it
a code smell and moved it to it's own method. Definitely made
using_tail_call_optimization/2 easier to read.

If we ignore using_calculate_multiples/1 this method is fastest up to about
100,000 items.

### Euler1.using_map_reduce/1

Included while trying to figure out if Enum.sum benefitted from Stream and to
show a third solution to the problem. This version uses Stream.filter to map
the values and then reduces the result. Oddly - if we ignore
using_calculate_multiples/1 - this one seems to perform best at 500,000 items
(about 6% faster than using_stream/1) and about the same as the using_stream/1
version at the other levels.

### Euler1.using_calculate_multiples/1

While working on Euler2 I realized the calculating the multiples might
actually be faster than iterating over every number - which lead to this
solution. We calculate the results for multiples of 3 and 5 separately using
tail calls that calculate the next number to assess based on the multiple rather
than creating a range of integers and iterating over them.

It turned out to be around 85% faster than the next fastest answer
for all examples.

# Euler2

## Even Fibonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two
terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.

## Approach
We start out by calling perform/1 - which serves as an interface when it's
passed an integer. It creates a tuple to track data with initial settings
based on the third Fibonacci number (3)... largely to simplify the methods.
It then recurses - using a pipeline to trnasform the tuple until it hits the
max value.
